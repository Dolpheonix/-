1. 프로그램의 메모리 영역
  1) 코드 영역
  2) 데이터 영역
  3) 스택 영역
  4) 힙 영역

2. SP, FP, PC
  1) SP(Stack Pointer) : 현재 함수 스택에서, 데이터가 추가될 위치 (SP 레지스터에 저장)
  2) FP(Frame Pointer) : 현재 함수 스택의 Bottom 부분 (FP 레지스터에 저장)
  3) 다중 스택 시 --> FP 위치에는 이전 FP의 주소값이 담겨 있음 --> 함수 반환 -> (SP = FP), (FP = OLD FP)
  4) PC : 현재 프로그램에서 읽어와야 할 명령의 위치 (PC 레지스터에 저장)

3. 멀티 스레딩
  1) 스레드(Thread) : 한 프로세스를 여러 흐름으로 나눈 것. 병렬 처리에 용이
  2) 스레드 vs 프로세스 : 스레드들은 모두 같은 프로세스에 속해 있기 때문에, Stack 영역을 제외한 부분들은 모두 공유하고 있음 -> context switching 시에 속도가 빠름 (cache flush를 할 필요가 없음)
  3) 스레드의 문제점 : 모두 한 프로세스에 속해있기 때문에, 같은 데이터에 접근하는 경우가 생길 수 있음. 이때 데이터의 값이 의도와 다르게 변할 수 있으므로, 동시에 여러 스레드가 한 데이터에 접근하는 것은 막아야 함
  4) mutex : 한번에 한 스레드만 가질 수 있는 객체. 갖는 행위를 lock/ 소유권을 놓는 행위를 unlock이라 함.
  5) semaphore : counter 변수를 통해 접근한 스레드의 수를 갖고 있음 (mutex는 semaphore의 counter 변수가 0 또는 1인 경우와 동치)

4. 멀티 스레딩 시의 문제 상황
  1) deadlock : 모든 스레드가 특정 resource의 소유권을 얻지 못해 아무 일도 하지 못하는 경우
  2) livelock : 두 스레드가 서로 소유권을 놓고, 획득하는 작업을 무한히 반복하는 경우 (deadlock을 회피하기 위해 코드를 어설프게 짠 경우 자주 발생)
  3) starvation : 특정 스레드가 획득권의 우선순위에서 밀려, 긴 시간동안 아무 일도 하지 못하는 경우

5. CPU 스케줄링
  1) Pre-emptive(선점) : 어떤 프로세스가 이미 진행 중인 프로세스를 밀어내고 CPU를 점유할 수 있음
  2) 알고리즘 : FCFS, SJF, RR, SRTF, ...

6. 리틀 인디언 VS 빅 인디언
  1) Litte Endian : 메모리 배열을 낮은 자리수부터 앞에 배치함 (사칙 연산에 용이)
  2) Big Endian : 반대 (읽기 편함)
  3) x86 아키텍쳐는 Little Endian을 사용함
